<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Async Programming in Python - Crash Course</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
        }
        
        .container {
            max-width: 900px;
            margin: 0 auto;
            background: white;
            padding: 40px;
            border-radius: 10px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
        }
        
        h1 {
            color: #667eea;
            font-size: 2.5em;
            margin-bottom: 10px;
            text-align: center;
        }
        
        .subtitle {
            text-align: center;
            color: #666;
            font-size: 1.1em;
            margin-bottom: 40px;
            font-style: italic;
        }
        
        h2 {
            color: #764ba2;
            font-size: 1.8em;
            margin-top: 40px;
            margin-bottom: 15px;
            border-bottom: 3px solid #667eea;
            padding-bottom: 10px;
        }
        
        h3 {
            color: #555;
            font-size: 1.3em;
            margin-top: 25px;
            margin-bottom: 10px;
        }
        
        p {
            margin-bottom: 15px;
            text-align: justify;
        }
        
        ul, ol {
            margin-left: 30px;
            margin-bottom: 15px;
        }
        
        li {
            margin-bottom: 8px;
        }
        
        code {
            background: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            color: #c7254e;
        }
        
        pre {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 20px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 20px 0;
            border-left: 4px solid #667eea;
        }
        
        pre code {
            background: none;
            color: #f8f8f2;
            padding: 0;
        }
        
        .analogy {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
        }
        
        .analogy strong {
            color: #856404;
        }
        
        .tip {
            background: #d1ecf1;
            border-left: 4px solid #17a2b8;
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
        }
        
        .warning {
            background: #f8d7da;
            border-left: 4px solid #dc3545;
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
        }
        
        .success {
            background: #d4edda;
            border-left: 4px solid #28a745;
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
        }
        
        .key-takeaway {
            background: #e7f3ff;
            border: 2px solid #667eea;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
        }
        
        .toc {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 5px;
            margin: 30px 0;
        }
        
        .toc h3 {
            margin-top: 0;
        }
        
        .toc ul {
            list-style: none;
            margin-left: 0;
        }
        
        .toc li {
            padding: 5px 0;
        }
        
        .toc a {
            color: #667eea;
            text-decoration: none;
        }
        
        .toc a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üöÄ Asynchronous Programming in Python</h1>
        <p class="subtitle">A Complete Crash Course for FastAPI, ML & GenAI Applications</p>

        <div class="toc">
            <h3>üìö Table of Contents</h3>
            <ul>
                <li><a href="#sync-vs-async">1. Synchronous vs Asynchronous Programming</a></li>
                <li><a href="#why-async">2. Why Async for FastAPI, ML & GenAI</a></li>
                <li><a href="#blocking">3. Blocking vs Non-Blocking Code</a></li>
                <li><a href="#async-await">4. Understanding async and await</a></li>
                <li><a href="#coroutine">5. What is a Coroutine</a></li>
                <li><a href="#event-loop">6. The Event Loop Explained</a></li>
                <li><a href="#sleep">7. asyncio.sleep vs time.sleep</a></li>
                <li><a href="#gather">8. Running Tasks Concurrently</a></li>
                <li><a href="#timing">9. Measuring Execution Time</a></li>
                <li><a href="#fastapi">10. FastAPI Async Endpoint Example</a></li>
                <li><a href="#mistakes">11. Common Beginner Mistakes</a></li>
                <li><a href="#when-not">12. When NOT to Use Async</a></li>
                <li><a href="#interview">13. Interview-Ready Key Takeaways</a></li>
            </ul>
        </div>

        <h2 id="sync-vs-async">1. Synchronous vs Asynchronous Programming</h2>
        
        <h3>Synchronous (Normal) Programming</h3>
        <p>In synchronous programming, tasks run one after another. When one task starts, everything else waits until it finishes.</p>

        <div class="analogy">
            <strong>üçî Real-Life Analogy:</strong> Imagine you're at a burger shop. The cashier takes your order, then makes your burger, then hands it to you. Only after finishing with you completely, they move to the next customer. Everyone else stands in line waiting.
        </div>

        <pre><code>import time

def make_burger(name):
    print(f"Making burger for {name}...")
    time.sleep(3)  # Takes 3 seconds
    print(f"Burger ready for {name}!")

# Synchronous execution
make_burger("Alice")  # Takes 3 seconds
make_burger("Bob")    # Takes 3 seconds
make_burger("Charlie") # Takes 3 seconds
# Total time: 9 seconds</code></pre>

        <h3>Asynchronous Programming</h3>
        <p>In asynchronous programming, when a task is waiting (like for data from an API), the program can do other work instead of just sitting idle.</p>

        <div class="analogy">
            <strong>üçî Real-Life Analogy:</strong> Now imagine a smart burger shop. The cashier takes Alice's order and gives it to the kitchen. While the kitchen is making Alice's burger, the cashier takes Bob's order. And while both burgers are cooking, the cashier takes Charlie's order. Everyone gets served faster!
        </div>

        <pre><code>import asyncio

async def make_burger(name):
    print(f"Making burger for {name}...")
    await asyncio.sleep(3)  # Simulate cooking time
    print(f"Burger ready for {name}!")

# Asynchronous execution
async def main():
    await asyncio.gather(
        make_burger("Alice"),
        make_burger("Bob"),
        make_burger("Charlie")
    )
# Total time: 3 seconds (all cook at the same time!)</code></pre>

        <h2 id="why-async">2. Why Async is Important for FastAPI, ML & GenAI</h2>

        <h3>The Problem with Synchronous Code in APIs</h3>
        <p>When you build an API that calls external services (databases, ML models, other APIs), synchronous code will block:</p>
        <ul>
            <li><strong>Database queries</strong> - Waiting for data to come back</li>
            <li><strong>API calls</strong> - Calling OpenAI, Hugging Face, or other services</li>
            <li><strong>File operations</strong> - Reading/writing files</li>
            <li><strong>ML inference</strong> - Waiting for model predictions</li>
        </ul>

        <p>If 100 users hit your API at the same time, synchronous code handles them one by one. Async code can handle all 100 simultaneously!</p>

        <div class="success">
            <strong>üí° Key Benefit:</strong> FastAPI with async can handle thousands of requests per second because it doesn't waste time waiting. While one request is waiting for the database, it processes other requests.
        </div>

        <h3>Real Example: Calling an LLM API</h3>
        <pre><code># ‚ùå Synchronous - Each request waits
def generate_text(prompt):
    response = openai.call(prompt)  # Blocks for 2 seconds
    return response

# If 10 users call this = 20 seconds total

# ‚úÖ Asynchronous - All requests happen together
async def generate_text(prompt):
    response = await openai.async_call(prompt)  # Doesn't block!
    return response

# If 10 users call this = 2 seconds total</code></pre>

        <h2 id="blocking">3. Blocking vs Non-Blocking Code</h2>

        <h3>Blocking Code</h3>
        <p>Code that makes your program wait and do nothing is called "blocking" code. The program is blocked from doing other work.</p>

        <p><strong>Examples of blocking operations:</strong></p>
        <ul>
            <li><code>time.sleep(5)</code> - Program freezes for 5 seconds</li>
            <li><code>requests.get(url)</code> - Waits for HTTP response</li>
            <li><code>file.read()</code> - Waits to read entire file</li>
            <li>Database queries using regular libraries</li>
        </ul>

        <h3>Non-Blocking Code</h3>
        <p>Non-blocking code says "I'll wait, but you go do other things meanwhile." It's like putting laundry in the washing machine and doing other chores while it runs.</p>

        <p><strong>Examples of non-blocking operations:</strong></p>
        <ul>
            <li><code>await asyncio.sleep(5)</code> - Others can run during this</li>
            <li><code>await httpx.get(url)</code> - Async HTTP request</li>
            <li><code>await file.read()</code> - Async file reading</li>
            <li>Database queries using async libraries (like asyncpg)</li>
        </ul>

        <div class="tip">
            <strong>üí° Simple Rule:</strong> If you see <code>await</code> before something, it's non-blocking. The program can do other work while waiting.
        </div>

        <h2 id="async-await">4. Understanding async and await</h2>

        <h3>The <code>async</code> Keyword</h3>
        <p>When you put <code>async</code> before a function, you're saying: "This function might need to wait for something, so it should not block other code."</p>

        <pre><code># Regular function (synchronous)
def greet():
    return "Hello"

# Async function
async def greet_async():
    return "Hello"</code></pre>

        <h3>The <code>await</code> Keyword</h3>
        <p>The <code>await</code> keyword is like saying: "Wait for this to finish, but let other code run meanwhile."</p>

        <p><strong>Important:</strong> You can only use <code>await</code> inside <code>async</code> functions!</p>

        <pre><code>import asyncio

async def fetch_data():
    print("Fetching data...")
    await asyncio.sleep(2)  # Wait 2 seconds, but don't block
    print("Data received!")
    return {"data": "some data"}

# To run an async function, you need asyncio.run()
asyncio.run(fetch_data())</code></pre>

        <div class="analogy">
            <strong>üç≥ Cooking Analogy:</strong>
            <ul>
                <li><code>async def</code> = "This is a recipe that has waiting time"</li>
                <li><code>await</code> = "Put it in the oven and work on other dishes while it bakes"</li>
            </ul>
        </div>

        <h2 id="coroutine">5. What is a Coroutine</h2>

        <p>A coroutine is simply a function defined with <code>async def</code>. That's it!</p>

        <p>When you call a coroutine, it doesn't run immediately. It returns a coroutine object that you need to <code>await</code> or run with <code>asyncio.run()</code>.</p>

        <pre><code>async def my_coroutine():
    return "I'm a coroutine!"

# This doesn't run the function, it creates a coroutine object
coro = my_coroutine()  

# To actually run it:
result = asyncio.run(coro)
print(result)  # "I'm a coroutine!"</code></pre>

        <div class="tip">
            <strong>üí° Simple Understanding:</strong> 
            <ul>
                <li>Regular function = Runs immediately when called</li>
                <li>Coroutine = Creates a "promise" to run later when you <code>await</code> it</li>
            </ul>
        </div>

        <h2 id="event-loop">6. The Event Loop Explained</h2>

        <p>The event loop is the brain behind async programming. It's like a manager that juggles multiple tasks.</p>

        <div class="analogy">
            <strong>üé™ Juggling Analogy:</strong> Imagine a juggler with multiple balls in the air. The juggler (event loop) keeps checking: "Which ball needs attention right now?" If one ball is in the air (task is waiting), the juggler focuses on another ball. This is exactly what the event loop does with your async tasks!
        </div>

        <h3>How It Works</h3>
        <ol>
            <li>You start Task A - it hits an <code>await</code> (starts waiting)</li>
            <li>Event loop says "Task A is waiting, let me check Task B"</li>
            <li>Task B runs - it also hits an <code>await</code></li>
            <li>Event loop says "Both are waiting, let me check if any finished"</li>
            <li>When Task A's wait is done, event loop resumes it</li>
            <li>This continues until all tasks are complete</li>
        </ol>

        <pre><code>import asyncio

async def task1():
    print("Task 1 started")
    await asyncio.sleep(2)
    print("Task 1 finished")

async def task2():
    print("Task 2 started")
    await asyncio.sleep(1)
    print("Task 2 finished")

async def main():
    # The event loop manages both tasks
    await asyncio.gather(task1(), task2())

asyncio.run(main())

# Output:
# Task 1 started
# Task 2 started
# Task 2 finished (after 1 second)
# Task 1 finished (after 2 seconds)</code></pre>

        <div class="success">
            <strong>üí° Key Point:</strong> You don't need to manually manage the event loop. <code>asyncio.run()</code> handles it for you. In FastAPI, the framework manages it automatically!
        </div>

        <h2 id="sleep">7. asyncio.sleep vs time.sleep</h2>

        <h3><code>time.sleep()</code> - The Blocker</h3>
        <p>This literally freezes your entire program. Nothing else can run.</p>

        <pre><code>import time

def task1():
    print("Task 1 started")
    time.sleep(2)  # ‚ùå EVERYTHING stops for 2 seconds
    print("Task 1 finished")

def task2():
    print("Task 2 started")
    time.sleep(1)  # ‚ùå EVERYTHING stops for 1 second
    print("Task 2 finished")

task1()  # Takes 2 seconds
task2()  # Takes 1 second
# Total: 3 seconds</code></pre>

        <h3><code>asyncio.sleep()</code> - The Polite One</h3>
        <p>This says "I'll wait, but others can keep working."</p>

        <pre><code>import asyncio

async def task1():
    print("Task 1 started")
    await asyncio.sleep(2)  # ‚úÖ Others can run during this
    print("Task 1 finished")

async def task2():
    print("Task 2 started")
    await asyncio.sleep(1)  # ‚úÖ Others can run during this
    print("Task 2 finished")

async def main():
    await asyncio.gather(task1(), task2())

asyncio.run(main())
# Total: 2 seconds (both run together!)</code></pre>

        <div class="warning">
            <strong>‚ö†Ô∏è Critical Rule:</strong> NEVER use <code>time.sleep()</code> in async code! It defeats the entire purpose. Always use <code>await asyncio.sleep()</code>.
        </div>

        <h2 id="gather">8. Running Tasks Concurrently with asyncio.gather</h2>

        <p><code>asyncio.gather()</code> is your best friend for running multiple async tasks at the same time.</p>

        <h3>Basic Usage</h3>
        <pre><code>import asyncio

async def fetch_user(user_id):
    await asyncio.sleep(1)  # Simulate API call
    return f"User {user_id} data"

async def main():
    # Run 3 tasks concurrently
    results = await asyncio.gather(
        fetch_user(1),
        fetch_user(2),
        fetch_user(3)
    )
    print(results)
    # Output: ['User 1 data', 'User 2 data', 'User 3 data']

asyncio.run(main())</code></pre>

        <h3>Real-World Example: Multiple API Calls</h3>
        <pre><code>import asyncio

async def call_llm(prompt):
    print(f"Calling LLM with: {prompt}")
    await asyncio.sleep(2)  # Simulate API call
    return f"Response for: {prompt}"

async def process_multiple_prompts():
    prompts = [
        "Explain quantum physics",
        "Write a poem about AI",
        "Summarize this article"
    ]
    
    # All 3 LLM calls happen simultaneously!
    responses = await asyncio.gather(
        *[call_llm(p) for p in prompts]
    )
    
    for response in responses:
        print(response)

asyncio.run(process_multiple_prompts())
# Total time: 2 seconds (not 6!)</code></pre>

        <div class="tip">
            <strong>üí° Pro Tip:</strong> Use <code>asyncio.gather()</code> when you have multiple independent async operations (API calls, database queries) that don't depend on each other. They'll all run together!
        </div>

        <h2 id="timing">9. Measuring Execution Time in Async Programs</h2>

        <p>To see the real benefit of async, you need to measure time properly.</p>

        <pre><code>import asyncio
import time

async def slow_operation():
    await asyncio.sleep(2)
    return "Done"

# Method 1: Using time.time()
async def main():
    start = time.time()
    
    # Sequential (one after another)
    await slow_operation()
    await slow_operation()
    
    end = time.time()
    print(f"Sequential time: {end - start:.2f} seconds")
    # Output: Sequential time: 4.00 seconds
    
    start = time.time()
    
    # Concurrent (both together)
    await asyncio.gather(
        slow_operation(),
        slow_operation()
    )
    
    end = time.time()
    print(f"Concurrent time: {end - start:.2f} seconds")
    # Output: Concurrent time: 2.00 seconds

asyncio.run(main())</code></pre>

        <h3>Practical Comparison</h3>
        <pre><code>import asyncio
import time

async def fetch_data(source):
    await asyncio.sleep(1)  # Simulate API call
    return f"Data from {source}"

async def compare_methods():
    sources = ["API-1", "API-2", "API-3", "API-4", "API-5"]
    
    # ‚ùå Sequential approach
    start = time.time()
    results = []
    for source in sources:
        result = await fetch_data(source)
        results.append(result)
    print(f"Sequential: {time.time() - start:.2f}s")
    # Output: Sequential: 5.00s
    
    # ‚úÖ Concurrent approach
    start = time.time()
    results = await asyncio.gather(
        *[fetch_data(source) for source in sources]
    )
    print(f"Concurrent: {time.time() - start:.2f}s")
    # Output: Concurrent: 1.00s

asyncio.run(compare_methods())</code></pre>

        <h2 id="fastapi">10. Simple FastAPI Async Endpoint Example</h2>

        <p>FastAPI is built for async! Let's see how to use it.</p>

        <h3>Basic Async Endpoint</h3>
        <pre><code>from fastapi import FastAPI
import asyncio

app = FastAPI()

@app.get("/")
async def root():
    return {"message": "Hello World"}

# This is async but doesn't await anything - that's okay!
@app.get("/user/{user_id}")
async def get_user(user_id: int):
    return {"user_id": user_id, "name": "Alice"}</code></pre>

        <h3>Real Async Operations</h3>
        <pre><code>from fastapi import FastAPI
import asyncio
import httpx  # Async HTTP library

app = FastAPI()

async def fetch_user_from_db(user_id: int):
    # Simulate database query
    await asyncio.sleep(0.5)
    return {"id": user_id, "name": f"User {user_id}"}

async def fetch_posts_from_db(user_id: int):
    # Simulate database query
    await asyncio.sleep(0.5)
    return [{"id": 1, "title": "Post 1"}, {"id": 2, "title": "Post 2"}]

@app.get("/user/{user_id}/profile")
async def get_user_profile(user_id: int):
    # Both queries run concurrently!
    user, posts = await asyncio.gather(
        fetch_user_from_db(user_id),
        fetch_posts_from_db(user_id)
    )
    
    return {
        "user": user,
        "posts": posts
    }
    # Total time: 0.5 seconds (not 1 second!)</code></pre>

        <h3>ML/GenAI Example</h3>
        <pre><code>from fastapi import FastAPI
import asyncio

app = FastAPI()

async def call_openai(prompt: str):
    # Simulate OpenAI API call
    await asyncio.sleep(2)
    return f"AI response to: {prompt}"

async def call_stability_ai(prompt: str):
    # Simulate image generation
    await asyncio.sleep(3)
    return f"Image URL for: {prompt}"

@app.post("/generate-content")
async def generate_content(prompt: str):
    # Generate both text and image concurrently!
    text_response, image_url = await asyncio.gather(
        call_openai(prompt),
        call_stability_ai(prompt)
    )
    
    return {
        "text": text_response,
        "image": image_url
    }
    # Total time: 3 seconds (not 5!)</code></pre>

        <div class="success">
            <strong>üí° FastAPI Magic:</strong> When you use <code>async def</code> in FastAPI, it automatically handles the event loop for you. You just need to use <code>await</code> for I/O operations!
        </div>

        <h2 id="mistakes">11. Common Beginner Mistakes in Async Programming</h2>

        <h3>Mistake 1: Using time.sleep() instead of asyncio.sleep()</h3>
        <pre><code># ‚ùå WRONG - Blocks everything
async def bad_function():
    import time
    time.sleep(2)  # This blocks the entire event loop!

# ‚úÖ CORRECT
async def good_function():
    await asyncio.sleep(2)  # This allows other tasks to run</code></pre>

        <h3>Mistake 2: Forgetting to await</h3>
        <pre><code># ‚ùå WRONG - Function doesn't actually run
async def fetch_data():
    return "data"

async def main():
    result = fetch_data()  # This just creates a coroutine object!
    print(result)  # Prints: <coroutine object fetch_data at 0x...>

# ‚úÖ CORRECT
async def main():
    result = await fetch_data()  # Actually runs the function
    print(result)  # Prints: "data"</code></pre>

        <h3>Mistake 3: Mixing sync and async incorrectly</h3>
        <pre><code># ‚ùå WRONG - Can't call async function from sync code directly
def sync_function():
    result = await some_async_function()  # SyntaxError!

# ‚úÖ CORRECT
def sync_function():
    result = asyncio.run(some_async_function())  # Works!

# OR better yet, make everything async
async def async_function():
    result = await some_async_function()  # Perfect!</code></pre>

        <h3>Mistake 4: Not using gather for parallel tasks</h3>
        <pre><code># ‚ùå INEFFICIENT - Runs sequentially
async def slow_way():
    result1 = await task1()  # Waits
    result2 = await task2()  # Then waits again
    result3 = await task3()  # Then waits again
    # Total: 6 seconds if each takes 2 seconds

# ‚úÖ EFFICIENT - Runs concurrently
async def fast_way():
    results = await asyncio.gather(
        task1(),
        task2(),
        task3()
    )
    # Total: 2 seconds (all run together!)</code></pre>

        <h3>Mistake 5: Using requests instead of httpx/aiohttp</h3>
        <pre><code># ‚ùå WRONG - requests library is synchronous
async def bad_api_call():
    import requests
    response = requests.get("https://api.example.com")  # Blocks!

# ‚úÖ CORRECT - Use async HTTP library
async def good_api_call():
    import httpx
    async with httpx.AsyncClient() as client:
        response = await client.get("https://api.example.com")  # Async!</code></pre>

        <div class="warning">
            <strong>‚ö†Ô∏è Remember:</strong> If you use any blocking operation (time.sleep, requests.get, regular file operations) inside an async function, you lose all the benefits of async!
        </div>

        <h2 id="when-not">12. When NOT to Use Async</h2>

        <p>Async is not always the answer! Here's when to avoid it:</p>

        <h3>1. CPU-Intensive Tasks</h3>
        <p>Async helps with I/O waiting (network, database, files). It does NOT help with heavy computation.</p>

        <pre><code># ‚ùå Async doesn't help here
async def calculate_fibonacci(n):
    # Heavy CPU work - async provides no benefit
    if n <= 1:
        return n
    return await calculate_fibonacci(n-1) + await calculate_fibonacci(n-2)

# ‚úÖ Use regular functions or multiprocessing
def calculate_fibonacci(n):
    if n <= 1:
        return n
    return calculate_fibonacci(n-1) + calculate_fibonacci(n-2)</code></pre>

        <h3>2. Simple Scripts and Small Projects</h3>
        <p>If your script just does one thing and exits, async adds unnecessary complexity.</p>

        <pre><code># For a simple one-time data fetch:
# ‚úÖ Simple and clear
import requests
response = requests.get("https://api.example.com")
print(response.json())

# ‚ùå Overkill for a simple script
import asyncio
import httpx

async def fetch():
    async with httpx.AsyncClient() as client:
        response = await client.get("https://api.example.com")
        return response.json()

asyncio.run(fetch())</code></pre>

        <h3>3. When You Have Blocking Dependencies</h3>
        <p>If you must use libraries that are synchronous (many ML libraries, certain databases), async won't help.</p>

        <ul>
            <li>Most scikit-learn operations</li>
            <li>Many pandas operations</li>
            <li>Traditional database libraries (use asyncpg, aiomysql instead)</li>
            <li>File operations (unless you use aiofiles)</li>
        </ul>

        <h3>When TO Use Async - Checklist</h3>
        <div class="success">
            ‚úÖ Use async when you:
            <ul>
                <li>Build web APIs (FastAPI, web servers)</li>
                <li>Make multiple API calls to external services</li>
                <li>Query databases frequently</li>
                <li>Read/write many files</li>
                <li>Handle many users simultaneously</li>
                <li>Work with websockets or streaming data</li>
            </ul>
        </div>

        <h2 id="interview">13. Interview-Ready Key Takeaways</h2>

        <div class="key-takeaway">
            <h3>üéØ Quick Answers for Interviews</h3>
            
            <p><strong>Q: What is async programming?</strong></p>
            <p>A: Async programming allows a program to handle multiple tasks concurrently. When one task is waiting (for I/O like API calls or database queries), the program can work on other tasks instead of sitting idle.</p>
            
            <p><strong>Q: Explain async/await in simple terms.</strong></p>
            <p>A: <code>async</code> marks a function as capable of pausing and resuming. <code>await</code> pauses the function at that point, allowing other code to run, and resumes when the awaited operation completes.</p>
            
            <p><strong>Q: What's the difference between concurrency and parallelism?</strong></p>
            <p>A: Concurrency is handling multiple tasks by switching between them (async). Parallelism is executing multiple tasks simultaneously on multiple CPU cores (multiprocessing). Async is concurrency, not parallelism.</p>
            
            <p><strong>Q: When would you use async in FastAPI?</strong></p>
            <p>A: Use async when making database queries, calling external APIs, reading files, or any I/O-bound operations. This allows FastAPI to handle thousands of requests efficiently.</p>
            
            <p><strong>Q: What is the event loop?</strong></p>
            <p>A: The event loop is the core of async execution. It manages and schedules async tasks, switching between them when they're waiting, ensuring efficient use of program time.</p>
            
            <p><strong>Q: Can you mix sync and async code?</strong></p>
            <p>A: Yes, but carefully. You can call sync functions from async functions normally. To call async functions from sync code, use <code>asyncio.run()</code>. Never use blocking operations in async functions.</p>
        </div>

        <h3>üîë Core Concepts Summary</h3>
        <ul>
            <li><strong>Coroutine:</strong> A function defined with <code>async def</code></li>
            <li><strong>await:</strong> Pauses a coroutine until an async operation completes</li>
            <li><strong>asyncio.gather():</strong> Runs multiple coroutines concurrently</li>
            <li><strong>Event loop:</strong> Manages and schedules all async tasks</li>
            <li><strong>Non-blocking:</strong> Code that doesn't freeze the program while waiting</li>
        </ul>

        <h3>üöÄ Best Practices</h3>
        <ol>
            <li>Always use <code>await asyncio.sleep()</code>, never <code>time.sleep()</code></li>
            <li>Use async HTTP libraries (httpx, aiohttp) not requests</li>
            <li>Use <code>asyncio.gather()</code> for concurrent independent tasks</li>
            <li>Don't use async for CPU-intensive work</li>
            <li>Use async database libraries (asyncpg, motor) for databases</li>
            <li>In FastAPI, use <code>async def</code> for endpoints with I/O operations</li>
        </ol>

        <h3>‚ö° Performance Rules of Thumb</h3>
        <ul>
            <li>If you have 10 API calls taking 1 second each:
                <ul>
                    <li>Sync: 10 seconds total</li>
                    <li>Async: 1 second total</li>
                </ul>
            </li>
            <li>Async benefits increase with more concurrent operations</li>
            <li>For single operations, sync and async perform similarly</li>
            <li>Async shines in high-traffic APIs and multiple I/O operations</li>
        </ul>

        <div class="analogy">
            <strong>üéì Final Analogy:</strong> Think of async programming like a chef in a restaurant. A bad chef (sync) cooks one dish completely before starting the next. A good chef (async) puts one dish in the oven, preps another while that's cooking, checks on a third, and keeps all dishes moving forward efficiently. Same kitchen, much more throughput!
        </div>

        <h3>üìö Next Steps</h3>
        <ol>
            <li>Practice writing async functions with asyncio.sleep()</li>
            <li>Build a FastAPI endpoint that calls multiple "APIs" concurrently</li>
            <li>Measure the time difference between sync and async approaches</li>
            <li>Try using httpx for real async HTTP requests</li>
            <li>Explore async database libraries for your database of choice</li>
        </ol>

        <div class="success" style="margin-top: 40px; text-align: center;">
            <h3>üéâ Congratulations!</h3>
            <p>You now understand async programming in Python! You're ready to build fast, scalable FastAPI applications for ML and GenAI projects.</p>
            <p style="margin-top: 15px;"><em>Remember: Start simple, measure performance, and use async when you have waiting time (I/O operations).</em></p>
        </div>

    </div>
</body>
</html>